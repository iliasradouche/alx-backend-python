#!/bin/bash

# kubctl-0x01: Kubernetes Application Scaling Script
# This script demonstrates how to scale applications in Kubernetes
# Author: ALX Backend Python Course
# Purpose: Scale Django messaging app, perform load testing, and monitor resources

set -e  # Exit on any error

# Color codes for output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
DEPLOYMENT_NAME="django-messaging-app"
SERVICE_NAME="django-messaging-service"
NAMESPACE="default"
TARGET_REPLICAS=3
LOAD_TEST_DURATION="30s"
LOAD_TEST_CONNECTIONS=10
LOAD_TEST_THREADS=2

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to check if required tools are installed
check_prerequisites() {
    print_status "Checking prerequisites..."
    
    # Check kubectl
    if ! command -v kubectl &> /dev/null; then
        print_error "kubectl is not installed or not in PATH"
        exit 1
    fi
    
    # Check if minikube is running
    if ! kubectl cluster-info &> /dev/null; then
        print_error "Kubernetes cluster is not accessible. Make sure minikube is running."
        print_status "Try running: minikube start"
        exit 1
    fi
    
    # Check wrk for load testing
    if ! command -v wrk &> /dev/null; then
        print_warning "wrk is not installed. Load testing will be skipped."
        print_status "To install wrk on Ubuntu/Debian: sudo apt-get install wrk"
        print_status "To install wrk on macOS: brew install wrk"
        return 1
    fi
    
    return 0
}

# Function to check if deployment exists
check_deployment() {
    print_status "Checking if deployment '$DEPLOYMENT_NAME' exists..."
    
    if ! kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE &> /dev/null; then
        print_error "Deployment '$DEPLOYMENT_NAME' not found in namespace '$NAMESPACE'"
        print_status "Make sure to apply the deployment.yaml first:"
        print_status "kubectl apply -f deployment.yaml"
        exit 1
    fi
    
    print_success "Deployment '$DEPLOYMENT_NAME' found"
}

# Function to get current replica count
get_current_replicas() {
    kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.spec.replicas}'
}

# Function to scale the deployment
scale_deployment() {
    local current_replicas=$(get_current_replicas)
    print_status "Current replicas: $current_replicas"
    
    if [ "$current_replicas" -eq "$TARGET_REPLICAS" ]; then
        print_warning "Deployment is already scaled to $TARGET_REPLICAS replicas"
        return 0
    fi
    
    print_status "Scaling deployment '$DEPLOYMENT_NAME' to $TARGET_REPLICAS replicas..."
    kubectl scale deployment $DEPLOYMENT_NAME --replicas=$TARGET_REPLICAS -n $NAMESPACE
    
    print_status "Waiting for deployment to be ready..."
    kubectl rollout status deployment/$DEPLOYMENT_NAME -n $NAMESPACE --timeout=300s
    
    print_success "Successfully scaled deployment to $TARGET_REPLICAS replicas"
}

# Function to verify pods are running
verify_pods() {
    print_status "Verifying that multiple pods are running..."
    
    echo -e "\n${BLUE}Current pods:${NC}"
    kubectl get pods -l app=$DEPLOYMENT_NAME -n $NAMESPACE -o wide
    
    local running_pods=$(kubectl get pods -l app=$DEPLOYMENT_NAME -n $NAMESPACE --field-selector=status.phase=Running --no-headers | wc -l)
    
    if [ "$running_pods" -ge "$TARGET_REPLICAS" ]; then
        print_success "$running_pods pods are running (target: $TARGET_REPLICAS)"
    else
        print_warning "Only $running_pods pods are running (target: $TARGET_REPLICAS)"
        print_status "Waiting a bit more for pods to start..."
        sleep 10
        kubectl get pods -l app=$DEPLOYMENT_NAME -n $NAMESPACE
    fi
}

# Function to get service URL for load testing
get_service_url() {
    # Check if service exists
    if ! kubectl get service $SERVICE_NAME -n $NAMESPACE &> /dev/null; then
        print_error "Service '$SERVICE_NAME' not found"
        return 1
    fi
    
    # For minikube, we need to use minikube service URL
    if command -v minikube &> /dev/null; then
        local service_url=$(minikube service $SERVICE_NAME --url -n $NAMESPACE 2>/dev/null)
        if [ -n "$service_url" ]; then
            echo "$service_url"
            return 0
        fi
    fi
    
    # Fallback to port-forward
    print_status "Using port-forward to access the service..."
    kubectl port-forward service/$SERVICE_NAME 8080:80 -n $NAMESPACE &
    local port_forward_pid=$!
    sleep 3
    echo "http://localhost:8080"
    
    # Store PID for cleanup
    echo $port_forward_pid > /tmp/kubctl-port-forward.pid
}

# Function to perform load testing
perform_load_test() {
    if ! command -v wrk &> /dev/null; then
        print_warning "Skipping load test - wrk not installed"
        return 0
    fi
    
    print_status "Getting service URL for load testing..."
    local service_url=$(get_service_url)
    
    if [ -z "$service_url" ]; then
        print_error "Could not determine service URL for load testing"
        return 1
    fi
    
    print_status "Service URL: $service_url"
    print_status "Performing load test for $LOAD_TEST_DURATION with $LOAD_TEST_CONNECTIONS connections..."
    
    echo -e "\n${BLUE}Load Test Results:${NC}"
    wrk -t$LOAD_TEST_THREADS -c$LOAD_TEST_CONNECTIONS -d$LOAD_TEST_DURATION --timeout=10s "$service_url/admin/"
    
    # Cleanup port-forward if it was used
    if [ -f /tmp/kubctl-port-forward.pid ]; then
        local pid=$(cat /tmp/kubctl-port-forward.pid)
        kill $pid 2>/dev/null || true
        rm -f /tmp/kubctl-port-forward.pid
    fi
    
    print_success "Load test completed"
}

# Function to monitor resource usage
monitor_resources() {
    print_status "Monitoring resource usage..."
    
    # Check if metrics-server is available
    if ! kubectl top nodes &> /dev/null; then
        print_warning "Metrics server not available. Resource monitoring will be limited."
        print_status "To enable metrics in minikube: minikube addons enable metrics-server"
        echo -e "\n${BLUE}Pod resource requests/limits:${NC}"
        kubectl describe deployment $DEPLOYMENT_NAME -n $NAMESPACE | grep -A 10 "Limits\|Requests" || true
        return 0
    fi
    
    echo -e "\n${BLUE}Node resource usage:${NC}"
    kubectl top nodes
    
    echo -e "\n${BLUE}Pod resource usage:${NC}"
    kubectl top pods -l app=$DEPLOYMENT_NAME -n $NAMESPACE
    
    echo -e "\n${BLUE}Pod resource requests and limits:${NC}"
    kubectl describe pods -l app=$DEPLOYMENT_NAME -n $NAMESPACE | grep -A 5 "Limits\|Requests" || true
}

# Function to show deployment status
show_deployment_status() {
    echo -e "\n${BLUE}Deployment Status:${NC}"
    kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o wide
    
    echo -e "\n${BLUE}ReplicaSet Status:${NC}"
    kubectl get replicaset -l app=$DEPLOYMENT_NAME -n $NAMESPACE
    
    echo -e "\n${BLUE}Service Status:${NC}"
    kubectl get service $SERVICE_NAME -n $NAMESPACE -o wide
}

# Function to display usage information
show_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help              Show this help message"
    echo "  -r, --replicas NUM      Set target number of replicas (default: 3)"
    echo "  -d, --duration TIME     Set load test duration (default: 30s)"
    echo "  -c, --connections NUM   Set load test connections (default: 10)"
    echo "  --skip-load-test        Skip the load testing phase"
    echo "  --skip-monitoring       Skip the resource monitoring phase"
    echo ""
    echo "Examples:"
    echo "  $0                      # Scale to 3 replicas and run full test"
    echo "  $0 -r 5                 # Scale to 5 replicas"
    echo "  $0 -d 60s -c 20         # Run 60s load test with 20 connections"
    echo "  $0 --skip-load-test     # Scale and monitor without load testing"
}

# Parse command line arguments
SKIP_LOAD_TEST=false
SKIP_MONITORING=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -r|--replicas)
            TARGET_REPLICAS="$2"
            shift 2
            ;;
        -d|--duration)
            LOAD_TEST_DURATION="$2"
            shift 2
            ;;
        -c|--connections)
            LOAD_TEST_CONNECTIONS="$2"
            shift 2
            ;;
        --skip-load-test)
            SKIP_LOAD_TEST=true
            shift
            ;;
        --skip-monitoring)
            SKIP_MONITORING=true
            shift
            ;;
        *)
            print_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# Main execution
main() {
    echo -e "${GREEN}=== Kubernetes Application Scaling Script ===${NC}"
    echo -e "${BLUE}Target deployment: $DEPLOYMENT_NAME${NC}"
    echo -e "${BLUE}Target replicas: $TARGET_REPLICAS${NC}"
    echo -e "${BLUE}Namespace: $NAMESPACE${NC}"
    echo ""
    
    # Step 1: Check prerequisites
    check_prerequisites
    WRK_AVAILABLE=$?
    
    # Step 2: Check if deployment exists
    check_deployment
    
    # Step 3: Scale the deployment
    scale_deployment
    
    # Step 4: Verify pods are running
    verify_pods
    
    # Step 5: Show deployment status
    show_deployment_status
    
    # Step 6: Perform load testing (if wrk is available and not skipped)
    if [ "$SKIP_LOAD_TEST" = false ] && [ $WRK_AVAILABLE -eq 0 ]; then
        perform_load_test
    elif [ "$SKIP_LOAD_TEST" = true ]; then
        print_status "Skipping load test as requested"
    fi
    
    # Step 7: Monitor resource usage (if not skipped)
    if [ "$SKIP_MONITORING" = false ]; then
        monitor_resources
    else
        print_status "Skipping resource monitoring as requested"
    fi
    
    echo ""
    print_success "Kubernetes scaling demonstration completed!"
    echo -e "${BLUE}Useful commands for further monitoring:${NC}"
    echo "  kubectl get pods -l app=$DEPLOYMENT_NAME -w"
    echo "  kubectl logs -l app=$DEPLOYMENT_NAME --tail=50"
    echo "  kubectl describe deployment $DEPLOYMENT_NAME"
    echo "  kubectl top pods -l app=$DEPLOYMENT_NAME"
}

# Run main function
main "$@"